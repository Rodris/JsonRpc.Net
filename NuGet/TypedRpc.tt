<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".ts" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Web" #>
<#@ assembly name="System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ assembly name="System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>

namespace TypedRpc {

	function setErrorMessage(error) {
		if (!error.message) {
			switch (error.code) {
				case -32700: error.message = "Invalid JSON was received by the server."; break;
				case -32600: error.message = "The JSON sent is not a valid Request object."; break;
				case -32601: error.message = "The method does not exist / is not available."; break;
				case -32602: error.message = "Invalid method parameter(s)."; break;
				case -32603: error.message = "Internal JSON-RPC error."; break;
				default: error.message = "Unknown error."; break;
			}
		}

		return error;
	}
	
	class MethodCall {
		private doneCallback = null;
        private failCallback = null;

        done(callback): MethodCall {
            this.doneCallback = callback;
			return this;
		}

        fail(callback): MethodCall {
            this.failCallback = callback;
			return this;
		}

		resolve(jResponse) {
			if (this.doneCallback) this.doneCallback(jResponse.result, jResponse);
		}

		reject(jResponse = null) {
			if (this.failCallback) {
				if (jResponse) this.failCallback(setErrorMessage(jResponse.error), jResponse);
				else this.failCallback(setErrorMessage({}), null);
			}
		}
	}

	var nextId = 1;

	function doPost<T>(method, args) {
		var parameters = [];
		for (var i in args) parameters.push(args[i]);
		var jsonRequest = JSON.stringify({ method: method, params: parameters, id: nextId });
		nextId++;
		var methodCall = new MethodCall();

		var request = new XMLHttpRequest();
        request.open('POST', '/typedrpc', true);

        request.onload = function () {
            if (request.status >= 200 && request.status < 400) {
                var jResponse = JSON.parse(request.responseText);
				if (jResponse.error) {
					methodCall.reject(jResponse);
				} else {
					methodCall.resolve(jResponse);
				}
                
            } else {
                methodCall.reject();
            }
        };

        request.onerror = function () {
            methodCall.reject();
        };

        request.send(jsonRequest);

		return methodCall;
	}

<#
	// Initializations
	IServiceProvider serviceProvider = (IServiceProvider)this.Host;
	dte = (EnvDTE.DTE) serviceProvider.GetService(typeof(EnvDTE.DTE));

	// Builds servers.
	PushIndent("    ");
	BuildServers();
	PopIndent();
#>
}
<#+
	// DTE
	public EnvDTE.DTE dte;

	// Current project.
	private EnvDTE.Project CurrentProject;

	// Types to build interfaces.
	List<EnvDTE.CodeType> Interfaces = new List<EnvDTE.CodeType>();

	// Adds an interface to build.
	void AddInterface(String codeTypeName) {
		// Ignores System interfaces.
		if (codeTypeName == null || codeTypeName.StartsWith("System")) return;

		// Ignores IOwinContext interface.
		if (codeTypeName.Equals("Microsoft.Owin.IOwinContext")) return;

		EnvDTE.CodeType codeType = CurrentProject.CodeModel.CodeTypeFromFullName(codeTypeName);
		if (codeType == null) return;

		if (!Interfaces.Any(ct => ct.FullName == codeType.FullName)) {
			Interfaces.Add(codeType);
		}
	}

	// Returns the name of a type.
	public String GetNameCodeTypeRef(EnvDTE.CodeTypeRef codeTypeRef) {
		String name;
		
		if (codeTypeRef.TypeKind == EnvDTE.vsCMTypeRef.vsCMTypeRefArray) {
			name = GetNameCodeTypeRef(codeTypeRef.ElementType) + "[]";

		} else if (codeTypeRef.TypeKind == EnvDTE.vsCMTypeRef.vsCMTypeRefVoid) {
			name = "void";

		} else if (codeTypeRef.TypeKind == EnvDTE.vsCMTypeRef.vsCMTypeRefCodeType) {
			name = GetNameClass(codeTypeRef.CodeType);

		} else {
			name = GetNameString(codeTypeRef.AsFullName);
		}

		if (name == null) name = "any";
		
		return name;
	}

	// Returns the name of a type.
	public String GetNameString(String codeTypeName) {
		EnvDTE.CodeType codeType;
		String name;
		
		codeType = CurrentProject.CodeModel.CodeTypeFromFullName(codeTypeName);

		if (codeType != null) name = GetNameCodeType(codeType);
		else name = codeTypeName;

		return name;
	}

	// Returns the name of a type.
	public String GetNameCodeType(EnvDTE.CodeType codeType) {
		String name;
		
		AddInterface(codeType.FullName);
		
		switch (codeType.FullName) {
			case "System.SByte":
			case "System.Byte":
			case "System.Char":
			case "System.Decimal":
			case "System.Double":
			case "System.Single":
			case "System.Int32":
			case "System.Int64":
				name = "number"; break;
				
			case "System.Boolean": name = "boolean"; break;
			case "System.String": name = "string"; break;
			case "System.Void": name = "void"; break;

			default:
				name = GetNameClass(codeType); break;
		}
		
		return name;
	}

	// Returns the name of a class.
	public String GetNameClass(EnvDTE.CodeType codeType) {
		String name;
		
		// Array
		name = GetNameArray(codeType);
		if (name != null) name = name + "[]";

		// Dictionary
		else if (codeType.FullName.StartsWith("System.Collections.Generic.Dictionary")) name = "any";

		// Task
		else if (codeType.FullName.Equals("System.Threading.Tasks.Task")) name = "void";
		else if (codeType.FullName.StartsWith("System.Threading.Tasks.Task")) name = GetNameGeneric(codeType.FullName);

		// Custom class.
		else {
			name = codeType.FullName.Split('.').Last();
		}
		
		return name;
	}

	// Returns the generic type.
	public String GetNameGeneric(String genericType) {
		int startIndex = genericType.IndexOf('<');
		int endIndex = genericType.LastIndexOf('>');

		if (startIndex == -1) return genericType;

		return GetNameString(genericType.Substring(startIndex + 1, (endIndex - startIndex - 1)));
	}

	// Returns the array type.
	public String GetNameArray(EnvDTE.CodeType codeType) {
		String name;
		
		if (codeType.FullName.EndsWith("[]")) {
			name = codeType.FullName.Substring(0, codeType.FullName.Length - 2);
			name = GetNameString(name);

		} else if (codeType.FullName.StartsWith("System.Collections.Generic.List")) {
			name = GetNameGeneric(codeType.FullName);

		} else {
			name = null;
		}

		return name;
	}

	public bool IsServer(EnvDTE.CodeClass clazz)
	{
		foreach (EnvDTE.CodeClass subclazz in clazz.Bases) {
			foreach (EnvDTE.CodeAttribute attr in clazz.Attributes) if (attr.FullName == "TypedRpc.TypedRpcHandler") return true;
			if (IsServer(subclazz)) return true;
		}

		return false;
	}

	// Builds server classes.
	public void BuildServers() {
		foreach (EnvDTE.Project prj in dte.Solution.Projects) {
			if (prj.CodeModel == null) continue;
			CurrentProject = prj;
			
			foreach(EnvDTE.CodeNamespace element in prj.CodeModel.CodeElements)
			{
				if (element.Name == "System") continue;
				if (element.Name == "Owin") continue;
				if (element.Name == "Newtonsoft") continue;
				if (element.Name == "MS") continue;
				if (element.Name == "Microsoft") continue;
			
				// Builds servers.
				BuildServers(element);
			}

			// Builds found types.
			BuildInterfaces();
		}
	}

	// Builds server class.
	public void BuildServers(EnvDTE.CodeNamespace container) {
		// Builds servers.
		foreach(EnvDTE.CodeElement element in container.Members)
		{
			if (element.Kind == EnvDTE.vsCMElement.vsCMElementClass)
			{
				if (IsServer((EnvDTE.CodeClass)element)) BuildClass((EnvDTE.CodeClass)element);
			}
			else if (element.Kind == EnvDTE.vsCMElement.vsCMElementNamespace)
			{
				BuildServers((EnvDTE.CodeNamespace)element);
			}
		}
	}

	// Builds class.
	public void BuildClass(EnvDTE.CodeClass clazz) {
		WriteLine("export class " + clazz.Name + " {");
		PushIndent("    ");
		BuildMethods(clazz);
		PopIndent();
		WriteLine("}");
		WriteLine("");
	}

	// Builds methods.
	public void BuildMethods(EnvDTE.CodeClass clazz) {
		foreach (EnvDTE.CodeElement method in clazz.Members) {
			if (method.Kind == EnvDTE.vsCMElement.vsCMElementFunction && method.Name != clazz.Name) BuildMethod(clazz, (EnvDTE.CodeFunction)method);
		}
	}

	// Builds a method.
	public void BuildMethod(EnvDTE.CodeClass clazz, EnvDTE.CodeFunction method) {
		String parameters;

		parameters = BuildParameters(method);

		WriteLine(method.Name + "(" + parameters + "): MethodCall {");
		PushIndent("    ");
		BuildMethodBody(clazz, method);
		PopIndent();
		WriteLine("}");
		WriteLine("");
	}

	// Builds a method body.
	public void BuildMethodBody(EnvDTE.CodeClass clazz, EnvDTE.CodeFunction method) {
		String methodName;
		String methodType;

		methodName = (clazz.Name + "." + method.Name);
		methodType = GetNameCodeTypeRef(method.Type);
		
		WriteLine(String.Format("return doPost<{0}>('{1}', arguments);", methodType, methodName));
	}
	
	// Builds a method parameters.
	public String BuildParameters(EnvDTE.CodeFunction method) {
		List<String> parms = new List<String>();
		String optional;
		
		foreach (EnvDTE80.CodeParameter2 parm in method.Parameters) {
			// Ignores IOwinContext parameters.
			if (GetNameCodeType(parm.Type.CodeType) == "IOwinContext") continue;

			optional = (parm.ParameterKind == EnvDTE80.vsCMParameterKind.vsCMParameterKindOptional) ? "?" : String.Empty;
			parms.Add(parm.Name + optional + ": " + GetNameCodeType(parm.Type.CodeType));
		}

		return String.Join(", ", parms);
	}

	// Builds found types.
	public void BuildInterfaces() {
		for (int i = 0; i < Interfaces.Count; i++) {
			BuildInterface(Interfaces[i]);
		}

		Interfaces.Clear();
	}

	// Builds interface.
	public void BuildInterface(EnvDTE.CodeType codeType) {
		WriteLine("export interface " + GetNameCodeType(codeType) + " {");
		PushIndent("    ");
		BuildProperties((EnvDTE.CodeClass)codeType);
		PopIndent();
		WriteLine("}");
		WriteLine("");
	}

	// Builds properties.
	public void BuildProperties(EnvDTE.CodeClass clazz) {
		foreach (EnvDTE.CodeElement prop in clazz.Members) {
			if (prop.Kind == EnvDTE.vsCMElement.vsCMElementProperty) BuildProperty((EnvDTE.CodeProperty)prop);
		}
	}

	// Builds a property.
	public void BuildProperty(EnvDTE.CodeProperty prop) {
		WriteLine(prop.Name + ": " + GetNameCodeTypeRef(prop.Type) + ";");
	}

#>

