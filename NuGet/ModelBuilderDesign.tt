<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".t4" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#
	// Initializations
	IServiceProvider serviceProvider = (IServiceProvider)this.Host;
	EnvDTE.DTE dte = (EnvDTE.DTE) serviceProvider.GetService(typeof(EnvDTE.DTE));
 
	var templateItem = dte.Solution.FindProjectItem(this.Host.TemplateFile);
	var project = templateItem.ContainingProject;
	var vsProject = project.Object as VSLangProj.VSProject;
	string assemblyDirective = "\<#@ assembly name=\"$(ProjectDir)$(OutDir)TypedRpc.dll\" \#>";

	foreach(var referenceObj in vsProject.References)
	{
		var reference = (VSLangProj.Reference)referenceObj;
		if (reference.Name == "TypedRpc") {
			assemblyDirective = string.Format("\<#@ assembly name=\"{0}\" \#>", reference.Path);
			break;
		}
	}

	WriteLine(assemblyDirective);
#>
\<#@ assembly name="EnvDTE" \#>
\<#@ assembly name="EnvDTE80" \#>
\<#@ assembly name="System.Core" \#>
\<#@ import namespace="System.Linq" \#>
\<#@ import namespace="System.Collections.Generic" \#>
\<#@ import namespace="TypedRpc.Client" \#>
\<#+
	// Creates the client model in runtime.
	public class ModelBuilderDesign : IModelBuilder
	{
		// DTE
		private EnvDTE.DTE Dte;

		// Current project.
		private EnvDTE.Project CurrentProject;
		
		// Found interfaces.
		private List<EnvDTE.CodeType> Interfaces = new List<EnvDTE.CodeType>();

		// A void type.
		private static readonly MType TypeVoid = new MType() {
			Name = "Void",
			FullName = "System.Void",
			Type = MType.MTType.System
		};

		// Constructor
		public ModelBuilderDesign(EnvDTE.DTE dte)
		{
			// Initializations
			Dte = dte;
		}

		// Builds model.
		public Model BuildModel()
		{
			Handler[] handlers = BuildHandlers();

			Model model = new Model()
			{
				Handlers = handlers,
				Interfaces = BuildInterfaces()
			};

			return model;
		}

		// Builds a model type.
		private MType BuildMType(EnvDTE.CodeType codeType)
		{
			// Declarations
			MType mType;

			// Validates type.
			if (codeType == null) return TypeVoid;

			// New type.
			mType = new MType();
			mType.Name = codeType.Name;
			mType.FullName = codeType.FullName;
			
			// Checks type type.
			if (codeType.FullName.EndsWith("[]")) mType.Type = MType.MTType.Array;
			else if (codeType.FullName.StartsWith("System.Collections.Generic.List")) mType.Type = MType.MTType.List;
			else if (codeType.FullName.StartsWith("System.Threading.Tasks.Task")) mType.Type = MType.MTType.Task;
			else if (codeType.FullName.StartsWith("System.Collections.Generic.Dictionary")) mType.Type = MType.MTType.Dictionary;
			else if (codeType.FullName.StartsWith("Microsoft.Owin.IOwinContext")) mType.Type = MType.MTType.OwinContext;
			else if (codeType.FullName.StartsWith("System")) mType.Type = MType.MTType.System;
			else mType.Type = MType.MTType.Custom;
			
			// If array.
			if (mType.Type == MType.MTType.Array)
			{
				// Adds its type.
				string codeTypeName = codeType.FullName.Substring(0, codeType.FullName.Length - 2);
				mType.GenericType = BuildMType(CurrentProject.CodeModel.CodeTypeFromFullName(codeTypeName));
			}
			
			// If List or Task.
			if (mType.Type == MType.MTType.List || mType.Type == MType.MTType.Task)
			{
				 mType.GenericType = BuildMType(GetGeneric(codeType.FullName));
			}
			
			// If custom.
			if (mType.Type == MType.MTType.Custom)
			{
				// Checks if type has already been added.
				if (!Interfaces.Any(it => it.FullName == codeType.FullName)) Interfaces.Add(codeType);
			}
			
			return mType;
		}

		// Returns the generic type.
		public EnvDTE.CodeType GetGeneric(String genericType) {
			int startIndex = genericType.IndexOf('<');
			int endIndex = genericType.LastIndexOf('>');

			if (startIndex < 0) return null;

			genericType = genericType.Substring(startIndex + 1, (endIndex - startIndex - 1));
			EnvDTE.CodeType codeType = CurrentProject.CodeModel.CodeTypeFromFullName(genericType);

			return codeType;
		}
		
		// Builds handlers.
		private Handler[] BuildHandlers()
		{
			List<Handler> handlers = new List<Handler>();

			foreach (EnvDTE.Project prj in Dte.Solution.Projects) {
				if (prj.CodeModel == null) continue;
				CurrentProject = prj;
			
				foreach(EnvDTE.CodeNamespace element in prj.CodeModel.CodeElements)
				{
					if (element.Name == "System") continue;
					if (element.Name == "Owin") continue;
					if (element.Name == "Newtonsoft") continue;
					if (element.Name == "MS") continue;
					if (element.Name == "Microsoft") continue;
			
					// Builds servers.
					handlers.AddRange(FindHandlers(element).Select(c => BuildHandler(c)));
				}
			}

			return handlers.ToArray();
		}

		// Finds handler classes.
		public List<EnvDTE.CodeClass> FindHandlers(EnvDTE.CodeNamespace container) {
			List<EnvDTE.CodeClass> handlers = new List<EnvDTE.CodeClass>();

			foreach(EnvDTE.CodeElement element in container.Members)
			{
				if (element.Kind == EnvDTE.vsCMElement.vsCMElementClass)
				{
					EnvDTE.CodeClass codeClass = (EnvDTE.CodeClass)element;
					if (!codeClass.IsAbstract && IsHandler(codeClass)) handlers.Add(codeClass);
				}
				else if (element.Kind == EnvDTE.vsCMElement.vsCMElementNamespace)
				{
					handlers.AddRange(FindHandlers((EnvDTE.CodeNamespace)element));
				}
			}

			return handlers;
		}

		// Checks if a class is a handler.
		public bool IsHandler(EnvDTE.CodeClass codeClass)
		{
			// Checks for handler attribute.
			foreach (EnvDTE.CodeAttribute attr in codeClass.Attributes) if (attr.FullName == "TypedRpc.TypedRpcHandler") return true;

			// Checks if any parent is handler.
			foreach (EnvDTE.CodeClass parentClass in codeClass.Bases) {
				if (IsHandler(parentClass)) return true;
			}

			return false;
		}

		// Builds a handler.
		private Handler BuildHandler(EnvDTE.CodeClass codeClass)
		{
			Method[] methods = BuildMethods(codeClass);

			Handler handler = new Handler()
			{
				Name = codeClass.Name,
				Methods = methods
			};

			return handler;
		}

		// Builds methods.
		public Method[] BuildMethods(EnvDTE.CodeClass codeClass) {
			List<Method> methods = new List<Method>();

			if (IsHandler(codeClass))
			{
				foreach (EnvDTE.CodeElement method in codeClass.Members)
				{
					if (method.Kind == EnvDTE.vsCMElement.vsCMElementFunction && method.Name != codeClass.Name)
					{
						methods.Add(BuildMethod((EnvDTE.CodeFunction)method));
					}
				}

				foreach (EnvDTE.CodeClass baseClass in codeClass.Bases)
				{
					methods.AddRange(BuildMethods(baseClass));
				}
			}

			return methods.ToArray();
		}

		// Builds a method.
		private Method BuildMethod(EnvDTE.CodeFunction codeFunction)
		{
			Parameter[] parameters = BuildParameters(codeFunction);

			Method method = new Method()
			{
				Name = codeFunction.Name,
				ReturnType = BuildMType(codeFunction.Type.CodeType),
				Parameters = parameters
			};

			return method;
		}

		// Builds parameters.
		public Parameter[] BuildParameters(EnvDTE.CodeFunction codeFunction) {
			List<Parameter> parameters = new List<Parameter>();

			foreach (EnvDTE80.CodeParameter2 parameter in codeFunction.Parameters) {
				if (parameter.Type.CodeType.FullName == "Microsoft.Owin.IOwinContext") continue;

				parameters.Add(BuildParameter(parameter));
			}

			return parameters.ToArray();
		}

		// Builds a method parameter.
		private Parameter BuildParameter(EnvDTE80.CodeParameter2 codeParameter)
		{
			Parameter parameter = new Parameter()
			{
				Name = codeParameter.Name,
				Type = BuildMType(codeParameter.Type.CodeType),
				IsOptional = (codeParameter.ParameterKind == EnvDTE80.vsCMParameterKind.vsCMParameterKindOptional)
			};

			return parameter;
		}

		// Builds the interfaces.
		private Interface[] BuildInterfaces()
		{
			// Declarations
			List<Interface> interfaces;
			int index;

			// Initializations
			interfaces = new List<Interface>();
			index = 0;

			// The code generation might find new interfaces, so we use the 'while' loop to check for updated 'Count'.
			while (index < Interfaces.Count)
			{
				// Builds the interface.
				interfaces.Add(BuildInterface(Interfaces[index]));

				// Next interface.
				index++;
			}

			// All interfaces generated.
			Interfaces.Clear();

			return interfaces.ToArray();
		}

		// Builds an interface.
		private Interface BuildInterface(EnvDTE.CodeType codeType)
		{
			Property[] properties = BuildProperties((EnvDTE.CodeClass)codeType);

			Interface theInterface = new Interface
			{
				Name = codeType.Name,
				Properties = properties
			};
			
			return theInterface;
		}

		// Builds properties.
		public Property[] BuildProperties(EnvDTE.CodeClass codeClass) {
			List<Property> properties = new List<Property>();

			foreach (EnvDTE.CodeProperty codeProperty in codeClass.Members) {
				if (codeProperty.Kind != EnvDTE.vsCMElement.vsCMElementProperty) continue;

				properties.Add(BuildProperty(codeProperty));
			}

			return properties.ToArray();
		}

		// Builds a property.
		private Property BuildProperty(EnvDTE.CodeProperty codeProperty)
		{
			Property property = new Property()
			{
				Name = codeProperty.Name,
				Type = BuildMType(codeProperty.Type.CodeType)
			};

			return property;
		}
	}

\#>

